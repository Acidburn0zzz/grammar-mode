const keywords = ("if while with else do try finally return break continue new delete throw " +
                  "debugger var const let function catch for switch case default in typeof instanceof " +
                  "true false this class super yield export import extends await async").split(" ")

grammar JavaScript {
  Program { Statement* space* eof }
  
  Statement {
    kw["if"] p["("] Expression p[")"]  Statement (kw["else"] Statement)? |
    kw["return"] Expression? semi |
    (kw["break"] | kw["continue"]) identifier? semi |
    kw["delete"] Expression semi |
    kw["debugger"] semi |
    Expression semi
  }

  BlockStatement {
    p["{"] Statement* p["}"]
  }
  
  PrimaryExpression {
    identifier |
    p["("] Expression p[")"] |
    kw["this"] | kw["true"] | kw["false"] | kw["null"] |
    regExp |
    token:{$.type == "number" || $.type == "string"} |
    p["["] (Expression p[","])* Expression? p["]"] |
    kw["function"] definedIdentifier? p["("] (definedIdentifier p[","]?) ! p[")"] BlockStatement |
    (kw["new"] | kw["await"] | kw["yield"]) Expression |
    op[null] Expression
  }

  Expression {
    PrimaryExpression (
      p["("] (Expression p[","]?)* p[")"] |
      p["["] Expression p["]"] |
      p["."] property |
      p[","] Expression |
      op["++"] | op["--"] |
      op["?"] Expression op[":"] Expression |
      op[null] Expression
    )*
  }
  
  regExp {
    "/" any (any ! "/")
  }

  semi {
    whitespace:{$match.indexOf("\n") > -1} | (whitespace (eof | ";"))
    // FIXME lookahead }
  }
  
  token {
    whitespace token=(punctuation | word | operator | number)
  } { return token }
  
  comment { "/*" (any ! "*/") }
  
  whitespace { (space+ | comment)* }
  
  word {
    (letter | "_" | "$") (letter | digit | "$" | "_")*
  } {
   if (("if while with else do try finally return break continue new delete " + // FIXME close over
  "throw debugger var const let function catch for switch case default in typeof instanceof " +
  "true false this class super yield export import extends await async").split(" ").indexOf($match) >= 0) return {type: "keyword", value: $match}
   else return {type: "identifier", value: $match}
  }

  // FIXME make these builtin?
  letter { /[a-z]/i }
  space { /\s/ }
  digit { /\d/ }

  operator {
    /[-+\/^%&=><*]+/
  } { return {type: "operator", value: $match} }

  op[value] { token:{$.type == "operator" && (!value || $.value == value)} }
  
  punctuation {
    /[()[\]{},.]/
  } { return {type: "punctuation", value: $match} }

  property { word }

  definedIdentifier { identifier }

  identifier { token:{$.type == "identifier"} }

  number {
    /0x[\da-f]+/i |
    /\d+(\.\d*)?(e-?\d+)?/i |
    /\.\d+(e-?\d+)?/i
  } { return {type: "number", value: $match} }

  string {
    "\"" (any | "\\" any) ! "\"" |
    "'" (any | "\\" any) ! "'"
  }
  
  kw[value] {
    token:{$.type == "keyword" && $.value == value}
  }
  
  p[value] {
    token:{$.type == "punctuation" && $.value == value}
  }
}
